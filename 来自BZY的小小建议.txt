致终有所获的你们：
	关于编程方面的一些拙见：
	1.芯片的选择：关于芯片的选择，我们一般选择Arduino或者Stm32，arduino比较适合大一的的同学，因为它编程的门槛相对较低，
而且开源库较多，别的学校使用arduino作为比赛主控芯片也挺多的，对于我们的比赛而言，arduino确实也够用，并且其与树莓派和openmv
的通讯会更方便。
	至于我们为什么选择K66，有多方面的因素。因为我们已经用了一年arduino，比赛最终目的还是自身的学习建设，所以我选择了K66
作为自己学习ARM嵌入式的契机，它和arduino在编程方面其实到后面也差不多，都是调用库，但是学习起来它会更丰满更专业化，有断点调试等
功能，并且性能也很优越，当然Stm32也可以，最关键的还是它能让你学到很多关于底层的东西。其次对于电机的闭环控制而言，它自带了编码器
解码的功能，但它只有两路解码，对于做四轮闭环而言还是差点意思，但可以用DMA计数。现在也有了四路解码的单片机―RT1052等，大家可以
自己去了解去选择。
	最后，每个芯片都有各自的用法和对问题的解决办法，对于芯片的选择还是看各位对于自己现阶段水平和期望达到的目标水平的一个权衡，
基础才是最关键的。
	2.编辑器的推荐：VS code，无论是用什么芯片来编程，都推荐大家使用这款代码编辑器，主要是清楚方便，然后可以通过GitHub来实现
整个团队的代码共享，同时操作，然后大家写代码一定要记得保存前一天的版本，不然有可能光辉的自己就回不去了。
	3.工训编程第一步：电机闭环
	电机闭环是非常重要的，如果仅仅是靠时间延迟会有很多不确定性并且后期调试起来会很麻烦（即便你有稳压器）
	闭环步骤：
		（1）霍尔编码器获取电机速度
		（2）PID速度环（使用增量式PID）/根据增量式离散PID公式 pid.result+=Kp[e（k）-e(k-1)]+Ki*e(k)+Kd[e(k)-2e(k-1)+e(k-2)]

void PID_Control(_pid_t *pid, int16 actual, int16 set)//速度控制
{
	float p = 0, i = 0, d = 0;
	pid->err = set - actual;
	p = pid->err - pid->last_err;
	i = pid->err;
	d = pid->err - 2 * pid->last_err + pid->last_last_err;
	pid->result += pid->kp * p +pid->ki * i + pid->kd * d;
	if(pid->result>9000)
		pid->result = 9000;
	else if(pid->result<-9000)
		pid->result = -9000;
	pid->last_last_err = pid->last_err;
	pid->last_err = pid->err;
}
以上只是一个示例，PID只是一个公式，套用进去简单，调参才是最关键的
 
		（3）通过上位机通讯进行PID调参（根据电机的当前速度和给定的目标速度的曲线来改变对应PID数值的权重）。这里也推荐
大家使用蓝牙进行上位机通讯，然后通过OLED和按钮搭配，用按钮来改PID数值会很方便
	4.整车的闭环
	之前是对四个电机分别进行速度闭环，接下来则是对整车的闭环
	根据车子的不同，对车子建立起差速的目标速度运动方程，根据循迹或者其他方式来获取车身与直线的偏差值建立起四轮差速的速度方程
	5.循迹闭环
	这里我们用位置式PID（增量式也行应该），根据上面的代码可以自己再找增量式PID代码修改并加到自己的代码中，循迹的偏差我是用
-9 -7 -5 -3 -1 1 3 5 7 9这样的方式给灯赋值，然后累加，但这样对灯的准确性要求挺高，大家可以按照自己的情况分类讨论直接给偏差值。然后
通过偏差值反应到循迹的PID后，输出目标速度，最后小车速度环再控制就行啦。
	6.定位闭环
	我们可以在小车侧面加循迹来判断是否定位或者再加上霍尔传感器的脉冲数，因为霍尔传感器的脉冲数也可以作为里程数来使用嘛，这里也
可以再造一个位置环，目标脉冲数和当前脉冲数，根据偏差然后给定速度值即可，一通百通。
	7.角度闭环
	通过以上我们的定位和小车走完全程应该不是问题，但我们还有一个避障部分需要走出循迹，这时候我们用什么来判断小车的情况呢？
脉冲数？那打滑不是GG。时间延迟？那每一次走出来几乎都不太一样。所以我这边是使用了MPU6050,姿态传感器，相信我，六轴就够了，九轴
这个容易受到小车内部磁场干扰，不太准。只要用Z轴的角速度积分获得咱们的角度值，也是和循迹一样的位置环来控制我们小车的角度就可以。
这里需要注意的是优先级的问题，在这边肯定是角度环最优先，循迹环关闭然后速度环就可以，然后可能因为打滑我们开的距离会稍有不同，所以这里
可以通过前面或者侧面的循迹来判断是否回到主战场，直接拐过来，不然很有可能出去(我们就是小车漂移太厉害出去了，就算是角度环也救不了那种)
	8.直道和弯道PID的转换
	可以通过里程计或者循迹的情况来转换速度PID的数值，这样可以实现在直道很潇洒而弯道也很稳的曼妙姿态
	9.舵机控制
	我们一般是使用舵机控制板，优点是方便调节，但缺点也是如此，并且需要车身定位很准，需要注意的是可能发送过去的信号和它实现的动作
不是同一个，这可能是你发送的数据进制和它接收的进制转换不一样。
	这里推荐一种输入坐标控制机械臂的机械臂驱动程序，一个是调试方便 只要程序里调x，y，z步进的距离就行 很节省时间 就像写车床g代码一样 
另一个就是搭配摄像头进行定点 将摄像头搜到的物料坐标发给stm32 然后对机械臂的x，y坐标闭环 绝对比靠上料区那三根横线定位更快更准确
	10.可以去我的GitHub上查看我们比赛的代码：https://github.com/baizhiyuan/ZIO
	11.做车一定要多多互相交流，不要闭门造车，借鉴其他人其他学校的经验很重要，一定要保持谦虚的心态，在这个过程中多学多挑战自己，这
才是比赛的魅力
	12.关于树莓派和单片机的通讯，网上有很多教程，包括树莓派开机自启程序，然后树莓派的TXRX一开始会被它本身的蓝牙占领，百度也有相关
解决办法，当然用我的树莓派镜像更方便
	13.关于opencv摄像头的选择，其实打光很重要，200万的像素不同于手机的像素，手机是靠算法撑起来的几千万像素所以会糊，工业上两百万
像素就是两百万真实像素点，两百万肯定够了，然后我选择的像素具有高动态就是适应光的能力很好，我们也可以尝试神经网络来做图像识别，因为我的
二值化对光的要求还是挺高的，但是物块本身会反光就很难顶。
	14.电机一定要选择四个一样的，不然到头来会很麻烦，我就是典型的失败案例，蜗轮蜗杆刹车虽然好但正反转真的很烧
	15.一定要搞清楚全局变量在中断里面的使用，使用参数结构体会更方便，指针也是很舒服的东西，用上你就会爱上
	16.小车可能真正开发的时间还是你调试的时间多，这很正常，但一定要在调试的时候反思怎么样才能更方便调试或者怎么样能避免同样的问题，
意识到了问题不要害怕大的改变，这也许就是你脱胎换骨的机会！
	最后，怕什么真理无穷，进一寸有一寸的欢喜，这是一次需要不断积淀与毅力的挑战，是创新与实践的碰撞，是各位的机遇也有我们的期许，
希望大家加油，最后取得好成绩！
